## **2-5 리팩터링 시 고려할 문제**

리팩터링이 적극저으로 도입해야 할 중요한 기법이지만 리팩터링에 딸려 오는 문제도 엄연히 있기에 어떻게 대처해야하는지 알고 있어야 한다.

### 새 기능 개발 속도 저하

리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

빠지기 쉬운 가장 위험한 오류는 리팩터링을 클린코드나 바람직한 엔지니어링의 습관처럼 도덕적인 이유로 정당화하는 것이다.

리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는게 아니라 개발 기간을 단축하고자 하는 것이다.

기능 추가 시간을 줄이고, 버그 수정시간을 줄여준다.

앞서 소프트웨어 개발 진행 그래프에서 좋은 설계 곡선을 위해서 하는 것이지 이쁜 코드를 위해서가 아니다.

### 코드 소유권

### 브랜치

버전 관리 시스템을 사용할때 마스터에서 브랜치를 하나씩 맡아서 작업을 하다가 마스터에 머지를 하게 되는데

장점으로는

작업이 끝나지 않은 코드가 마스터에 섞이지 않고 기능이 추가 될때마다 버전을 명확히 나눌수 있어서 좋고 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어서 좋다.

단점은
브랜치 작업이 길어질수록 마스터로 통합이 어렵다.
수시로 리베이스나 머지를 해서 마스터와 맞춰나가야하는데 이런 부분에서 에러나 버그가 나기쉽다.

마스터로의 머지 주기를 2~3일에서 혹은 하루단위를 추천하는데 CI 지속적 통합과 TBD 트렁크 기반 개발을 강조했다.

CI에 따르면 모든 팀원이 하루에 최소 한번은 마스터와 통합한다. 이렇게 브랜칯들과의 차이를 크게 벌리는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출수 있다고 한다.

하지만 CI를 적용하기 위해서는 치러야 할 대가가 있다. 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

### 테스팅

리팩터링을 하더라도 동작이 깨지지 않아야한다.
만약 꺠지더라도 빠르게 원인 파악 및 해결이 이루어진다면 상관없지만 원인을 못찾게되면 가장 최근 상태로 돌려야한다.

여기에서 핵심은 오류를 재빨리 잡는 것이라고 하는데
이때 필요한게 테스트 스위트라고 한다.

테스트 스위트

> 테스트 케이스들을 하나로 묶은 것, 그리고 그것은자신의 테스트 케이스들을 실행합니다.

테스트코드는 리팩토링뿐만 아니라 새 기능 추가도 훨씬 안전하게 진행할수 있도록 도와준다.

또 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할수 있다.

### 레거시

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움되지만 레거시기 때문에 테스트 코드가 없을 확률이 상당히 높다.

대규모 레거시 시스템을 테스트코드 없이 명료하게 리팩터링하기는 어렵다.

단번에 리팩터링을 하기보다는 관련된 부분끼리 나눠서 하나씩 공략하는 방법이 효율적이다.

### 데이터베이스
